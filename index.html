<!DOCTYPE html>
<html>    
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>常理</title>
  <meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://litterGuy.github.io/">
  <link rel="alternate" type="application/atom+xml" title="常理" href="https://litterGuy.github.io/feed.xml" />
  <script src="/scripts/jquery-1.11.2.min.js"></script>
  <script src="/scripts/pithy.js"></script>
</head>


  <body>
    <header class="header">
	<div class="header-container">
		<div class="nav">
			
			<span class="title">
				<li>
					<a href="/index.html">主页</a>
				</li>
			</span>			
			
			
				<li>
					<a href="/archive.html">归档</a>
				</li>			
			
			
				<li>
					<a href="/category.html">目录</a>
				</li>			
			
			
				<li>
					<a href="/about.html">关于</a>
				</li>			
			
		</div>
		<div class="description"> 随笔杂记 </div>		
		<ul class="social-links">
			<li>
				<a href="https://github.com/litterGuy" title="Github">
					<img width="19px" height="19px" src="/images/github.png"/>
				</a>
			</li>
			<li>
				<a href="/feed.xml" title="RSS">
					<img width="19px" height="19px" src="/images/rss.png"/>
				</a>
			</li>
			<li>
				<a href="https://twitter.com/洛水尽" title="Twitter">
					<img width="19px" height="19px" src="/images/twitter.png"/>
				</a>
			</li>
		</ul>		
	</div>
</header>

    <br>
    <div class="page-content">
      <div class="wrapper">
        <div class="home">
  <ul class="post-list">
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%8A%82%E7%82%B9/2021/06/02/RedHat%E5%AE%89%E8%A3%85chia.html">Red Hat下chia安装和启动</a>
        </h3>
        <span class="post-meta">2021-06-02 08:06</span>
        <hr id="line">
		<div class="content">
		<h1 id="更新库安装python">更新库，安装python</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/go/2021/05/06/gomobile%E7%9A%84%E4%BD%BF%E7%94%A8.html">gomobile的使用</a>
        </h3>
        <span class="post-meta">2021-05-06 16:05</span>
        <hr id="line">
		<div class="content">
		<h1 id="gomobile的使用">gomobile的使用</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/go/2021/04/07/go1.15bug_export_ordinal_too_large.html">Error: export ordinal too large after upgrading to Go 1.15</a>
        </h3>
        <span class="post-meta">2021-04-07 16:04</span>
        <hr id="line">
		<div class="content">
		<h1 id="error-export-ordinal-too-large-after-upgrading-to-go-115">Error: export ordinal too large after upgrading to Go 1.15</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/oracle/2021/02/24/navicat-oracle%E5%AD%97%E7%AC%A6%E9%9B%86%E9%97%AE%E9%A2%98.html">navicat oracle字符集问题</a>
        </h3>
        <span class="post-meta">2021-02-24 11:02</span>
        <hr id="line">
		<div class="content">
		<h1 id="navicat-oracle字符集问题">navicat oracle字符集问题</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/oracle/2021/02/24/oracle%E5%AD%97%E7%AC%A6%E9%9B%86%E4%BF%AE%E6%94%B9.html">oracle字符集修改</a>
        </h3>
        <span class="post-meta">2021-02-24 11:02</span>
        <hr id="line">
		<div class="content">
		<h1 id="oracle字符集修改">oracle字符集修改</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/oracle/2021/02/24/oracle%E5%9C%A8docker%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html">oracle在docker下的安装配置</a>
        </h3>
        <span class="post-meta">2021-02-24 10:02</span>
        <hr id="line">
		<div class="content">
		<h1 id="oracle在docker下的安装配置">oracle在docker下的安装配置</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/go/2021/02/18/protobuf%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8.html">protobuf学习使用</a>
        </h3>
        <span class="post-meta">2021-02-18 16:02</span>
        <hr id="line">
		<div class="content">
		<h1 id="protobuf学习使用">protobuf学习使用</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/android/2020/12/15/%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8CBazel%E9%97%AE%E9%A2%98.html">Error:Could not run Bazel info</a>
        </h3>
        <span class="post-meta">2020-12-15 13:12</span>
        <hr id="line">
		<div class="content">
		<h1 id="errorcould-not-run-bazel-info">Error:Could not run Bazel info</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/docker/2020/12/08/docker%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5%E5%A4%B1%E6%95%88.html">docker重新进入容器时“/etc/profile”中环境变零失效问题</a>
        </h3>
        <span class="post-meta">2020-12-08 17:12</span>
        <hr id="line">
		<div class="content">
		<p>在docker容器中的/etc/profile配置了环境变量，容器未重新启动是可以正常使用的，但是一旦重启就失效了，解决办法是在/root/.bashrc文件最下面添加如下指令：</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/docker/2020/12/01/docker%E5%BC%80%E5%90%AFapi.html">docker开启api</a>
        </h3>
        <span class="post-meta">2020-12-01 13:12</span>
        <hr id="line">
		<div class="content">
		<h1 id="docker常见端口">Docker常见端口</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/docker/2020/11/30/docker%E7%A7%81%E6%9C%8D-nexus3.html">docker私服搭建-nexus3</a>
        </h3>
        <span class="post-meta">2020-11-30 10:11</span>
        <hr id="line">
		<div class="content">
		<h1 id="nexus-3">Nexus 3</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/thrift/2020/11/26/%E4%BD%BF%E7%94%A8thrift.html">使用thrift</a>
        </h3>
        <span class="post-meta">2020-11-26 09:11</span>
        <hr id="line">
		<div class="content">
		<h1 id="使用thrift">使用thrift</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/ssl/tls/2020/11/25/tls%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86.html">tls学习整理</a>
        </h3>
        <span class="post-meta">2020-11-25 11:11</span>
        <hr id="line">
		<div class="content">
		<h1 id="ssltls整理">SSL/TLS整理</h1>
<p>主要按照以下四个方面进行</p>
<ul>
  <li><a href="#一什么是ssltls">什么是SSL/TLS</a></li>
  <li><a href="#二协议流程">协议流程</a></li>
  <li><a href="#三使用wireshark抓取网络包">使用wireshark抓取网络包</a></li>
  <li><a href="#四使用ssllabs对域名进行分析">使用ssllabs对域名进行分析</a></li>
  <li><a href="#五ssltls异常处理思路">SSL/TLS异常处理思路</a></li>
</ul>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/go/2020/11/25/go%E7%AC%94%E8%AE%B0.html">go 笔记</a>
        </h3>
        <span class="post-meta">2020-11-25 10:11</span>
        <hr id="line">
		<div class="content">
		<p>目前尚需详细查看内容：</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/im/2020/03/27/im%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3.html">im部署文档</a>
        </h3>
        <span class="post-meta">2020-03-27 09:03</span>
        <hr id="line">
		<div class="content">
		<p><strong>一、部署聊天服务器文件上传服务配置</strong>
（一般由运维部署，也可以自己部署，后期统一）
1、安装tomcat</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1、systemctl status tomcat（查看是否有安装的tomcat或使用 ps -ef|grep tomcat。有tomcat直接跳过该部）
2、yum info tomcat
3、yum -y install tomcat（默认安装到/usr/share/tomcat/）
</code></pre></div></div>
<blockquote>
  <p>1、vi /usr/share/tomcat/conf/server.xml 修改server.xml 端口改为8088
2、进入 /usr/share/tomcat/webapps/ 目录下 上传assist.war 
3、systemctl start tomcat 启动tomcat解压包
4、 vi /usr/share/tomcat/webapps/assist/WEB-INF/classes/jdbc.properties 修改当前数据库账
号密码</p>
</blockquote>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/mysql/2020/02/21/mysqldump%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F.html">mysqldump备份与还原</a>
        </h3>
        <span class="post-meta">2020-02-21 13:02</span>
        <hr id="line">
		<div class="content">
		<p>#一. 备份类型</p>
<blockquote>

  <p>逻辑备份：把数据导出到一个文档中（.sql/.txt）
适合场景：中小型数据库</p>

  <p>物理备份：保存/usr/local/mysql/data数据库文件目录
适合场景：大型数据库</p>

  <p>在线热备（冗余）：需要有多台机器，主备模式，集群模式</p>
</blockquote>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/2020/01/07/ngrinder.html">ngrinder</a>
        </h3>
        <span class="post-meta">2020-01-07 08:01</span>
        <hr id="line">
		<div class="content">
		<p>1、下载
在<a href="https://github.com/naver/ngrinder/releases">https://github.com/naver/ngrinder/releases</a>选择合适版本下载</p>


        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/nginx/2019/11/21/nginx-301%E8%B7%B3%E8%BD%AChttps%E5%90%8Epost%E8%AF%B7%E6%B1%82%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html">nginx 301跳转https后post请求失效问题解决</a>
        </h3>
        <span class="post-meta">2019-11-21 13:11</span>
        <hr id="line">
		<div class="content">
		<p>app本地请求是http端口,后来升级https强制301跳转,设置如下</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
    listen 80;
    server name www.XXX.com;
    rewrite ^/(.*)$   https://www.XXX.com/$1 permanent;
}
</code></pre></div></div>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/git/2019/06/18/git%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.html">git开发流程</a>
        </h3>
        <span class="post-meta">2019-06-18 10:06</span>
        <hr id="line">
		<div class="content">
		<p><strong>Master 分支</strong></p>
<ol>
  <li>Master 分支应该始终和生产环境保持一致。</li>
  <li>由于 master 和生产代码是一致的，所以没有人包括技术负责人能在 master 上直接开发。</li>
  <li>真正的开发代码应当写在其他分支上。</li>
</ol>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/kafka/2019/06/13/kafka-%E5%85%A5%E9%97%A8.html">kafka-入门</a>
        </h3>
        <span class="post-meta">2019-06-13 14:06</span>
        <hr id="line">
		<div class="content">
		<p><strong>概念：</strong></p>
<ol>
  <li>kafka作为一个集群运行在一个或多个服务器上。</li>
  <li>kafka集群存储的消息是以topic为类别记录的。</li>
  <li>每个消息（也叫记录record，我习惯叫消息）是由一个key，一个value和时间戳构成。</li>
</ol>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html">访问者模式</a>
        </h3>
        <span class="post-meta">2019-06-10 18:06</span>
        <hr id="line">
		<div class="content">
		<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F.html">模板模式</a>
        </h3>
        <span class="post-meta">2019-06-10 18:06</span>
        <hr id="line">
		<div class="content">
		<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html">策略模式</a>
        </h3>
        <span class="post-meta">2019-06-10 18:06</span>
        <hr id="line">
		<div class="content">
		<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a>
        </h3>
        <span class="post-meta">2019-06-10 18:06</span>
        <hr id="line">
		<div class="content">
		<h1 id="状态模式">状态模式</h1>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html">观察者模式</a>
        </h3>
        <span class="post-meta">2019-06-10 17:06</span>
        <hr id="line">
		<div class="content">
		<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例模式</a>
        </h3>
        <span class="post-meta">2019-06-10 16:06</span>
        <hr id="line">
		<div class="content">
		<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 
注意： 
1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html">工厂模式</a>
        </h3>
        <span class="post-meta">2019-06-10 16:06</span>
        <hr id="line">
		<div class="content">
		<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html">备忘录模式</a>
        </h3>
        <span class="post-meta">2019-06-10 15:06</span>
        <hr id="line">
		<div class="content">
		<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html">中介者模式</a>
        </h3>
        <span class="post-meta">2019-06-10 15:06</span>
        <hr id="line">
		<div class="content">
		<p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html">迭代器模式</a>
        </h3>
        <span class="post-meta">2019-06-10 14:06</span>
        <hr id="line">
		<div class="content">
		<p>用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
迭代器模式属于行为型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html">设计模式的六大原则</a>
        </h3>
        <span class="post-meta">2019-06-10 11:06</span>
        <hr id="line">
		<div class="content">
		<p>设计模式三个分类
<img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3382485420,3660862088&amp;fm=26&amp;gp=0.jpg" alt="此处输入图片的描述" /></p>


        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html">解释器模式</a>
        </h3>
        <span class="post-meta">2019-06-04 19:06</span>
        <hr id="line">
		<div class="content">
		<p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html">命令模式</a>
        </h3>
        <span class="post-meta">2019-06-04 18:06</span>
        <hr id="line">
		<div class="content">
		<p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html">责任链模式</a>
        </h3>
        <span class="post-meta">2019-06-04 18:06</span>
        <hr id="line">
		<div class="content">
		<p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html">代理模式</a>
        </h3>
        <span class="post-meta">2019-06-04 15:06</span>
        <hr id="line">
		<div class="content">
		<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/06/04/JDK%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html">JDK和CGLIB动态代理区别</a>
        </h3>
        <span class="post-meta">2019-06-04 15:06</span>
        <hr id="line">
		<div class="content">
		<ol>
  <li><strong>JDK动态代理</strong></li>
</ol>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a>
        </h3>
        <span class="post-meta">2019-06-04 15:06</span>
        <hr id="line">
		<div class="content">
		<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html">外观模式</a>
        </h3>
        <span class="post-meta">2019-06-04 14:06</span>
        <hr id="line">
		<div class="content">
		<p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.html">装饰模式</a>
        </h3>
        <span class="post-meta">2019-06-04 14:06</span>
        <hr id="line">
		<div class="content">
		<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html">组合模式</a>
        </h3>
        <span class="post-meta">2019-06-04 13:06</span>
        <hr id="line">
		<div class="content">
		<p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/04/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html">桥接模式</a>
        </h3>
        <span class="post-meta">2019-06-04 10:06</span>
        <hr id="line">
		<div class="content">
		<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/03/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html">适配器模式</a>
        </h3>
        <span class="post-meta">2019-06-03 18:06</span>
        <hr id="line">
		<div class="content">
		<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/03/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">原型模式</a>
        </h3>
        <span class="post-meta">2019-06-03 17:06</span>
        <hr id="line">
		<div class="content">
		<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2019/06/03/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html">建造者模式</a>
        </h3>
        <span class="post-meta">2019-06-03 16:06</span>
        <hr id="line">
		<div class="content">
		<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder类是独立于其他对象的。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk%E7%AE%97%E6%B3%95/2019/04/26/%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a>
        </h3>
        <span class="post-meta">2019-04-26 11:04</span>
        <hr id="line">
		<div class="content">
		<p>二叉查找树（BST）具备什么特性呢？</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk%E7%AE%97%E6%B3%95/2019/04/25/Blowfish%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html">Blowfish 加密算法</a>
        </h3>
        <span class="post-meta">2019-04-25 14:04</span>
        <hr id="line">
		<div class="content">
		<p>Blowfish加密算法的特点：</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/25/%E5%86%85%E7%BD%AE%E9%94%81%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81.html">内置锁与显示锁</a>
        </h3>
        <span class="post-meta">2019-04-25 14:04</span>
        <hr id="line">
		<div class="content">
		<p>Java中具有通过Synchronized实现的内置锁，和ReentrantLock实现的显示锁</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/25/ReentrantLock.html">ReentrantLock</a>
        </h3>
        <span class="post-meta">2019-04-25 14:04</span>
        <hr id="line">
		<div class="content">
		<p>使用 synchronized 来做同步处理时，锁的获取和释放都是隐式的，实现的原理是通过编译后加上不同的机器指令来实现。</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/22/Random-String%E6%9D%A5%E6%89%93%E5%8D%B0%E5%87%BA-Hello-World.html">Random String来打印出”Hello World”</a>
        </h3>
        <span class="post-meta">2019-04-22 18:04</span>
        <hr id="line">
		<div class="content">
		<p>```
public static String randomString(int i)
{
    Random ran = new Random(i);
    StringBuilder sb = new StringBuilder();
    while (true)
    {
        int k = ran.nextInt(27);
        if (k == 0)
            break;</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/22/%E6%B3%9B%E5%9E%8B.html">泛型</a>
        </h3>
        <span class="post-meta">2019-04-22 17:04</span>
        <hr id="line">
		<div class="content">
		<p><strong>泛型基础</strong></p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/19/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87.html">三目运算符----类型自动提升</a>
        </h3>
        <span class="post-meta">2019-04-19 11:04</span>
        <hr id="line">
		<div class="content">
		<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void main(String[] args) {
	int i=99;
	System.out.println("99999判断结果:"+(true?'a':99999));
	System.out.println("-1判断结果   :"+(true?'a':-1));
	System.out.println("0判断结果    :"+(true?'a':0));
	System.out.println("65535判断结果:"+(true?'a':65535));
	System.out.println("65536判断结果:"+(true?'a':65536));
	System.out.println("i判断结果    :"+(true?'a':i));
}
</code></pre></div></div>
<p>运算结果如下：</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html">线程池</a>
        </h3>
        <span class="post-meta">2019-04-19 10:04</span>
        <hr id="line">
		<div class="content">
		<ul>
  <li>线程池原理</li>
</ul>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/19/synchronized.html">synchronized</a>
        </h3>
        <span class="post-meta">2019-04-19 10:04</span>
        <hr id="line">
		<div class="content">
		<p>众所周知 synchronized 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/18/Java-%E6%9E%9A%E4%B8%BE%E6%9F%A5%E6%89%BE%E5%B9%B6%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0.html">Java 枚举查找并不抛异常的实现</a>
        </h3>
        <span class="post-meta">2019-04-18 17:04</span>
        <hr id="line">
		<div class="content">
		<ul>
  <li>问题</li>
</ul>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/18/jvm%E5%A0%86%E5%86%85%E5%AD%98.html">jvm堆内存</a>
        </h3>
        <span class="post-meta">2019-04-18 15:04</span>
        <hr id="line">
		<div class="content">
		<p><img src="http://static.codeceo.com/images/2018/12/006tNbRwly1fy359itj30j30mn0ecjuh.jpg" alt="此处输入图片的描述" /></p>


        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/17/ConcurrentHashMap.html">ConcurrentHashMap</a>
        </h3>
        <span class="post-meta">2019-04-17 14:04</span>
        <hr id="line">
		<div class="content">
		<ol>
  <li>Base 1.7
    <blockquote>

      <p>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
    </blockquote>
  </li>
</ol>

        </div>
		<br>
      </li>
    
      <li>
        <br>
        <h3>
          <a class="post-link" href="/jdk/2019/04/17/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html">Java类加载机制</a>
        </h3>
        <span class="post-meta">2019-04-17 14:04</span>
        <hr id="line">
		<div class="content">
		<p>##Java类加载机制的七个阶段</p>

        </div>
		<br>
      </li>
    
  </ul>
</div>

      </div>
    </div>
    
    <footer class="footer">
  <div id="gotop">^</div>
  <br>
	@2015 Pithy Theme by Pawpaw.
</footer>

    
  </body>

</html>
