<!DOCTYPE html>
<html>    
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>synchronized</title>
  <meta name="description" content="众所周知 synchronized 关键字是解决并发问题常用解决方案，有以下三种使用方式:">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://litterGuy.github.io/jdk/2019/04/19/synchronized.html">
  <link rel="alternate" type="application/atom+xml" title="常理" href="https://litterGuy.github.io/feed.xml" />
  <script src="/scripts/jquery-1.11.2.min.js"></script>
  <script src="/scripts/pithy.js"></script>
</head>


  <body>
    <header class="header">
	<div class="header-container">
		<div class="nav">
			
				<li>
					<a href="/index.html">主页</a>
				</li>			
			
			
				<li>
					<a href="/archive.html">归档</a>
				</li>			
			
			
				<li>
					<a href="/category.html">目录</a>
				</li>			
			
			
				<li>
					<a href="/about.html">关于</a>
				</li>			
			
		</div>
		<div class="description"> 随笔杂记 </div>		
		<ul class="social-links">
			<li>
				<a href="https://github.com/litterGuy" title="Github">
					<img width="19px" height="19px" src="/images/github.png"/>
				</a>
			</li>
			<li>
				<a href="/feed.xml" title="RSS">
					<img width="19px" height="19px" src="/images/rss.png"/>
				</a>
			</li>
			<li>
				<a href="https://twitter.com/洛水尽" title="Twitter">
					<img width="19px" height="19px" src="/images/twitter.png"/>
				</a>
			</li>
		</ul>		
	</div>
</header>

    <br>
    <div class="page-content">
      <div class="wrapper">
        <div class="post">
  <br>
  <header class="post-header">
    <h1 class="post-title">synchronized</h1>
    <p class="post-meta">2019-04-19</p>
  </header>

  <article class="post-content">
    <p>众所周知 synchronized 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>

<ul>
  <li>同步普通方法，锁的是当前对象。</li>
  <li>同步静态方法，锁的是当前 Class 对象。</li>
  <li>同步块，锁的是 () 中的对象。</li>
</ul>

<p>实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。</p>

<p>具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。</p>

<p>其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>

<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。</p>

<p>流程图如下:
<img src="https://camo.githubusercontent.com/2755b62baffab9f16d90a8d2d101b2fa18b0873b/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744e6337396c7931666e3237666b6c30376a6a333165383068796e306e2e6a7067" alt="此处输入图片的描述" /></p>

<p><strong>锁优化</strong></p>

<hr />
<p>synchronized 很多都称之为重量锁，JDK1.6 中对 synchronized 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。</p>

<p><strong>轻量锁</strong></p>

<blockquote>
  <p>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。</p>

  <p>如果更新成功，当前线程就获得了锁。</p>

  <p>如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。</p>

  <p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p>

  <p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。</p>
</blockquote>

<ul>
  <li>解锁</li>
</ul>

<blockquote>
  <p>轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁)</p>

  <p>轻量锁能提升性能的原因是：</p>

  <p>认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。</p>
</blockquote>

<p><strong>偏向锁</strong></p>

<blockquote>
  <p>为了进一步的降低获取锁的代价，JDK1.6 之后还引入了偏向锁。</p>

  <p>偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。</p>

  <p>当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>
</blockquote>

<ul>
  <li>释放锁</li>
</ul>

<blockquote>
  <p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。</p>

  <p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 -XX:-UseBiasedLocking 来关闭偏向锁，并默认进入轻量锁。</p>
</blockquote>

<p><strong>其他优化</strong></p>

<ul>
  <li>适应性自旋</li>
</ul>

<blockquote>
  <p>在使用 CAS 时，如果操作失败，CAS 会自旋再次尝试。由于自旋是需要消耗 CPU 资源的，所以如果长期自旋就白白浪费了 CPU。JDK1.6加入了适应性自旋:</p>

  <p>如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</p>
</blockquote>


  </article>
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key=/jdk/2019/04/19/synchronized data-title=synchronized data-url=随笔杂记//jdk/2019/04/19/synchronized.html></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"pawpaw"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</div>

      </div>
    </div>
    
    <footer class="footer">
  <div id="gotop">^</div>
  <br>
	@2015 Pithy Theme by Pawpaw.
</footer>

    
  </body>

</html>
